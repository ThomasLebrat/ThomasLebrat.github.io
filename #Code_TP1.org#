#+TITLE: CODE TP 1 
#+DATE: <2023-02-01 mer.>

#+OPTIONS: d:t

:tiroir:
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
# #+SETUPFILE: file:///~/org-html-themes/org/theme-readtheorg-local.setup
:end:


* Recommendations 


** librairies

On installe une librairie avec la commande suivante :

#+BEGIN_SRC sh
pip install matplotlib.pyplot
#+END_SRC


Dans un script Python on réalise des imports ciblés de librairies avec les instructions suivantes : 

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
#+END_SRC


** Ecriture

On se donne quelques conventions pour écrire un code lisible par tous 
- mettre des commentaires ~# step i : description ...~ à chaque moment important
- utiliser des noms de variables explicites ~Texp~ fait référence à la température expérimentale
- se limiter dans un premier temps à l'utilisation de 2 librairies d'usage courant :
  - ~numpy~ pour le calcul vectoriel
  - ~matplotlib~ pour le tracé de graphes

** liste

On se remémore quelques instructions de base

#+BEGIN_SRC jupyter-python :results output verbatim :exports both
Personnages = ['RIRI', 'FIFI', 'LOUOU']
taille = len(Amis)
print(taille)
Personnages.append('GEO')
print(Personnages)
#+END_SRC

#+RESULTS:
:RESULTS:
8
['RIRI', 'FIFI', 'LOUOU', 'GEO']
:END:



* préparatifs

- On importe les librairies standards et on fixe les valeurs des constantes physiques.
- On saisit les tableaux de valeurs expérimentales, d'altitude et de température.
- On teste l'execution dans une première cellule (Jupyter Notebook par ex)


#+BEGIN_SRC jupyter-python :results output raw :exports both
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

#Constants
M = 29.0e-3
R = 8.31
P0 = 1.0e5
g0 = 9.8
RT = 6.4e3
pi = np.pi

#Altitude en km
zexp = np.array([0.0, 5.0, 10.0, 12.0, 20.0, 25.0, 30.0,35.0, 40.0,
                 45.0, 48.0, 52.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0, 84.0, 92.0, 95.0,100.0])

Texp = np.array([15.0, -18.0, -49.0, -56.0, -56.0, -51.0, -46.0, -37.0,
                 -22.0, -8.0, -2.0, -2.0, -7.0, -17.0, -33.0, -54.0, -65.0, -79.0, -86.0,-86.0, -81.0, -72.0])

#+BEGIN_SRC jupyter-python
fig, ax = plt.subplots()
ax.plot( Texp,zexp)
plt.savefig("graph_Q0.png")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/a60bc0e706dedf58e67f07c07108a1cd231a7778.png]]

- Pour les utilisateurs avancés, possible également d'utiliser ~pandas~ pour importer le fichier de données ~.csv~ (à tester dans une séance ultérieure)


Les sections qui suivent contiennent des premiers éléments de correction. 
Les lignes de code seront susceptibles d'être remaniées au fil de l'eau et/ou commentées en fonction de vos retours (difficultés/suggestions d'améliorations)


* Q1 - Formule de l'interpolation -                                 :Tableau:

Ce point a été traité en séance au tableau (voir polycopié pour une synthèse).

$$ $$

* Q2 - Ecriture de la fonction T(z,unite)                              :CODE:

Il y a un petit raisonnement à mener pour 



Certains d'entre vous choissisent de faire la conversion dans un cellule à part pour plus de rigeur. C'est certainement une /meilleure pratique/ à privilégier.

Il y a 3 termes dans cette formule d'interpolation 
- le premier pour gérer le décallage éventuel du au choix de l'unité
- la valeur de la température de référence
- l'incrément de température calcul en utilisant la pete

C'est seulement lorsque l'altitude considérée est supérieure à l'altitude du point de mesure $zkm>zexp$

La fonctionalité de conversion d'unité peut être implémentée dans un deuxième temps.


$$ temperature = alpha*273 + Texp[i] + \frac{zkm - zexp[i]}{ (zexp[i + 1] - zexp[i])*(Texp[i + 1] - Texp[i]) }$$


#+BEGIN_SRC jupyter-python :results output raw :exports both
def T(z, unite):
    zkm = z / 1000 # Conversion en km pour comparaison dans la liste
    alpha = 1
    if unite == 'C':
        alpha = 0 # Pas de décalage pour la température en °C
    i = 0
    while zkm > zexp[i + 1]: # Recherche de l’indice i
        i = i + 1
    temperature = alpha*273 + Texp[i] + (zkm - zexp[i])/(zexp[i + 1] - zexp[i])*(Texp[i + 1] - Texp[i]) # Interpolation linéaire
    return temperature
#+END_SRC

#+RESULTS:

* Q3                                                                   :CODE:

#+BEGIN_SRC jupyter-python :results output raw :exports both
N = 1000 # Nombre de points
zmax = 100.0e3 # Altitude max (en m)
dz = zmax/(N - 1) # Pas spatial (en m)
zatm = np.array([k*dz for k in range(N)]) # Altitudes
Tatm = np.array([T(zatm[k], 'C') for k in range(N)]) # Températures
#+END_SRC

#+RESULTS:


* Q4                                                                   :CODE:

#+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Tatm,zatm)
ax.plot( Tatm,zatm)
plt.savefig("graph_Q4.png")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/bce4b3c06ad759508b4d43d220f481ab699a1e96.png]]


* Q5                                                                :TABLEAU:

* Q6                                                                :TABLEAU:

* Q7

#+BEGIN_SRC jupyter-python :results output raw :exports both
def g(z): # Champ de pesanteur
    return g0 * RT**2 / (RT + z)**2
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :results output raw :exports both
# Calcul du champ de pression par la méthode d’Euler
Patm = [P0] # Initialisation
for k in range(N - 1): # Il reste N - 1 termes à calculer
    Patm.append(Patm[k] - M*g(zatm[k])*Patm[k]*dz/(R*T(zatm[k], 'K')))
Patm = np.array(Patm) # Conversion en tableau
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Patm,zatm)
plt.savefig("graph_Q7.png")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/452be962270a3497e78002b893546d6fd18cd61c.png]]


* Q8                                                                   :CODE:


#+BEGIN_SRC jupyter-python  
def masse_atm(z): # Calcul de la masse d’air jusqu’à l’altitude z
    masse = 0
    k = 0
    while zatm[k] < z: # On arrête le calcul à l’altitude z
        dm = 4*np.pi*(RT + z)**2*M*Patm[k]/(R*T(zatm[k], 'K'))*dz
        masse = masse + dm
        k = k + 1
    return masse
#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-python  
mtot = masse_atm(100e3) # Masse d'air dans l'atmosphère terrestre
print('Masse de l\'atmosphère :', mtot, 'kg')
#+END_SRC

#+RESULTS:
:RESULTS:
Masse de l'atmosphère : 1.0772432715500982e+16 kg
:END:


#+BEGIN_SRC jupyter-python  
mtropo = masse_atm(12e3) # Masse d'air dans la troposphère
print('Proportion d\'air dans la troposphère :', mtropo/mtot)
#+END_SRC

#+RESULTS:
:RESULTS:
Proportion d'air dans la troposphère : 0.004662119957938924
:END:


* Q9                                                                :TABLEAU:

#+BEGIN_SRC jupyter-python
Patm2 = [P0]
for k in range(N - 1):
    Patm2.append(Patm2[k] - M*g0*Patm2[k]*dz/(R*T(zatm[k], 'K')))
Patm2 = np.array(Patm2)
ecart1 = 100 * abs(Patm - Patm2) / Patm # Ecart relatif
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python  
fig, ax = plt.subplots()
ax.plot( ecart1,zatm)
plt.savefig("graph_Q9.png")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/976970ca5f6bd41e43d20f0987b5263393e64f05.png]]
:END:



* Q10                                                                  :CODE:

#+BEGIN_SRC jupyter-python :results output raw :exports both
Piso = [P0]
for k in range(N - 1):
    Piso.append(Piso[k] - M*g0*Piso[k]*dz/(R*T(0, 'K')))
Piso = np.array(Piso)
ecart2 = 100 * abs(Piso - Patm) / Patm # Ecart relatif
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart2,zatm)
plt.savefig("graph_Q10.png")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/feb8952deba53f364be4f1ff78bba0a4ceaf611b.png]]


* Q11                                                               :TABLEAU:

* Q12                                                          :CODE:TABLEAU:

#+BEGIN_SRC jupyter-python
ztropo, Ttropo = [], [] # Initialisation des listes
k = 0
while zatm[k] < 10e3: # On sélectionne les données jusqu’à 10km
    ztropo.append(zatm[k])
    Ttropo.append(T(zatm[k], 'K'))
    k = k + 1
# Régression linéaire T(z)=a*z+b
a, b = np.polyfit(ztropo, Ttropo, 1) # Calcul de la régression linéaire
Tlin = [a*z + b for z in ztropo] # Modèle linéaire de la température

print(a,b)


Pgradient = [P0]
for k in range(len(ztropo) - 1):
    Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
Pgradient = np.array(Pgradient)
ecart3 = 100 * abs(Pgradient - Patm) / Patm

#+END_SRC

#+RESULTS:
:RESULTS:
-0.006402700270027003 287.5138802168507
# [goto error]

ValueErrorTraceback (most recent call last)
<ipython-input-32-fe345e124b4e> in <module>
     16     Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
     17 Pgradient = np.array(Pgradient)
---> 18 ecart3 = 100 * abs(Pgradient - Patm) / Patm

ValueError: operands could not be broadcast together with shapes (100,) (1000,) 
:END:


#+BEGIN_SRC jupyter-python

#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

ValueErrorTraceback (most recent call last)
<ipython-input-29-8ae4b0545b27> in <module>
      3     Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
      4 Pgradient = np.array(Pgradient)
----> 5 ecart3 = 100 * abs(Pgradient - Patm) / Patm

ValueError: operands could not be broadcast together with shapes (100,) (1000,) 
:END:


#+BEGIN_SRC jupyter-python  
fig, ax = plt.subplots()
ax.plot( ecart3,zatm)
plt.savefig("graph_Q12.png")
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]

NameErrorTraceback (most recent call last)
<ipython-input-25-c79f05ea19df> in <module>
      1 fig, ax = plt.subplots()
----> 2 ax.plot( ecart3,zatm)
      3 plt.savefig("graph_Q12.png")

NameError: name 'ecart3' is not defined
[[file:./.ob-jupyter/61d2780d035746e2a1d41c3696837d1141c39f65.png]]
:END:

#+BEGIN_SRC jupyter-python  

#+END_SRC

