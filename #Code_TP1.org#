#+TITLE: Structure Thermique de l'atmopsh√®re
#+AUTHOR: Thomas Lebrat
#+DATE: <2023-02-01 mer.>

#+OPTIONS: d:nil

:tiroir:
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
# #+SETUPFILE: file:///~/org-html-themes/org/theme-readtheorg-local.setup
:end:


* Introduction

Un ballon-sonde mesure les caract√©ristiques de l'atmosph√®re √† l'aide d'instruments embarqu√©s jusque des altitudes variables (selon les mod√®les, ouverts ou ferm√©s). On retient souvent une valeur approch√©e de $50~km$ pour l'altitude maximale. Est-ce bien r√©aliste ? Pourquoi une telle limite ? 

Les donn√©es obtenues en fonction de l'altitude sont renvoy√©es au sol par signal radio. L'importance de ces donn√©es /in situ/ est cruciale pour affiner les mod√®les physiques de l'atmosph√®re utilis√©s en m√©t√©orologie et notamment /calibrer/ les mesures r√©alis√©es par satellite √† des fin de t√©l√©d√©tection.


** Objectifs de l'activit√© et comp√©tences travaill√©es

Nous vous fournissons ici une vingtaine de valeurs de temp√©rature √† analyser. Les questions Q1 √† Q12 vous guident pour atteindre les 3 ojectifs principaux de cette activit√© : 

1) Construire des profils verticaux $\rightarrow$ identifier les couches atmosph√©riques
2) D√©terminer un profil de pression $\looparrowright$ 100 km tenant compte de $\Delta T$
3) Discuter la pertinence du choix de certaines hypoth√®ses (iso-g, iso-T)

Une participation active et constructive est toujours bienvenue et valoris√©e. Vous √™tes autoris√©s (et encourag√©s !) √† nous solliciter pour nous soumettre vos questions scientifiques (ex: /Mais c'est quoi un gradient adiabatique ?/) ou techniques (ex: /Comment faire converger mon algorithme efficacement ?/). 

Voici une liste des comp√©tences qui sont travaill√©es dans ce TP : 

- Impl√©menter des m√©thodes num√©riques : *interpolation* et *int√©gration*
- Comprendre le principe de la *r√©gression* 
- Explorer quelques possibit√©s du language ~Python~ + ~numpy~ \footnote{avec l'utilisation de ~Matplotlib~ syntaxe proche de ~MATLAB~}

Acc√©ssoirement, vous pourrez utiliser des librairies sp√©cialis√©es telles que ~scipy~, ~pandas~, ~plotly~ (...) et d'autres outils que vous aimeriez partager s'il permettent de gagner du temps de d√©veloppement ou du temps de calcul.



** Documentation et remerciements

*** biblio
:PROPERTIES:  
:UNNUMBERED: t  
:END:  
 Cette activit√© est tr√®s largement inspir√©e de la lecture des documents suivants (liste √† compl√©ter)
 
+ [[https://labolycee.org/mecanique-du-vol-dun-ballon-sonde][Exo Bac]]
+ [[http://www.msc.univ-paris-diderot.fr/~phyexp/pmwiki.php/Convention/ConvectionEtPanacheThermique][Images de panaches thermiques (UP7)]]
+ [[https://web.archive.org/web/20081119164748/http://www.meteofrance.com/FR/glossaire/designation/693_initie_view.jsp][Glossaire Meteo France]]
+ [[http://b.louchart.free.fr/Concours_et_examens/Centrale_Supelec/Sujets/2008_TSI_Physique_1.html][Sujet Concours TSI 2008]]
+ [[https://planet-terre.ens-lyon.fr/ressource/mouvts-enveloppes-fluides2.xml][Site Plan√®te Terre ENS Lyon]]

*** TODO nommenclature et origine des noms des couches
:PROPERTIES:  
    :UNNUMBERED: t
    :END:      




** Tableau comment√©


#+BEGIN_EXPORT latex
Voici le profil vertical avec une petite une visualisation ~ASCII~ artisanale\footnote{Depuis Emacs(org-mode), on applique la formule :  \#+TBLFM: ~\$4='(orgtbl-ascii-draw \$3 175 290)~}. 
#+END_EXPORT

 #+NAME: temp
 #+name: name
 #+attr_latex: : |c|c|c|c|
 #+caption:
 | z(km) | T(¬∞C) |  T(K) | T (ASCII Profile) |
 |-------+-------+-------+-------------------|
 |   100 |   -72 |   201 | WWh               |
 |    95 |   -81 |   192 | WV                |
 |    92 |   -86 | *187* | W;                |
 |    84 |   -86 | *187* | W;                |
 |    80 |   -86 | *187* | W;                |
 |    75 |   -79 |   194 | WW                |
 |    70 |   -65 |   208 | WWWc              |
 |    65 |   -54 |   219 | WWWWl             |
 |    60 |   -33 |   240 | WWWWWWV           |
 |    55 |   -17 |   256 | WWWWWWWW!         |
 |    52 |    -7 |   266 | WWWWWWWWW!        |
 |    48 |    -2 | *271* | WWWWWWWWWW        |
 |    45 |    -2 | *271* | WWWWWWWWWW        |
 |    40 |    -8 |   265 | WWWWWWWWWc        |
 |    35 |   -22 |   251 | WWWWWWWH          |
 |    30 |   -37 |   236 | WWWWWWc           |
 |    25 |   -46 |   227 | WWWWWc            |
 |    20 |   -56 | *217* | WWWWc             |
 |    12 |   -56 | *217* | WWWWc             |
 |    10 |   -49 |   224 | WWWWW.            |
 |     5 |   -18 |   255 | WWWWWWWW;         |
 |     0 |    15 | *288* | WWWWWWWWWWWV      |
#+TBLFM: $4=$2+273
#+TBLFM: $4='(orgtbl-ascii-draw $3 175 290)

On rep√®re les tendances discut√©es au premmier cours, les creux et les bosses correspondant aux /minima/ et /maxima/ locaux. Des valeurs identiques pourraient indiquer des bandes stationnaires mais l'√©chantillonage est insuffisant pour trancher.

Le tableau de donn√©es est saisi √† la main puis comment√© en groupe : 

+  << il fait froid >> : en effet la temp√©rature $T$ est  toujours (vraiment ?) n√©gative au del√† de 5 km
+ √† l'√©vidence, $T$ n'est connue qu'en certaines altitudes, espac√©es de mani√®re /irr√©guli√®re/
+ depuis le sol, des tendances sont identifiables : $\searrow$ , $\nearrow$ , $\searrow$ , $\nearrow$
+ des mesures font appara√Ætre des valeurs identiques (stagnation ?)
+ les √©tudiants se demandent alors si cela ne posera pas de probl√®me num√©rique (ce point √† √©t√© trait√© en d√©tail √† l'oral en TP ...)

Attention, la conversion en Kelvin peut-√™tre source d'erreurs ! Pour nos calculs, on prendra garde √† bien v√©rifier que le zero absolu correspond √† une temp√©rature de $-273~C$ c-√†-d que : 

$$T(K) = T(C) + 273 $$


* TP Sondage Atmosph√©rique - Correction 

** pr√©paratifs

 - On importe les librairies standards et on fixe les valeurs des constantes physiques.
 - On saisie les tableaux de valeurs de temp√©rature
 - On teste l'execution dans une premi√®re cellule (Jupyter Notebook par ex)


 #+BEGIN_SRC jupyter-python :results output raw :exports both
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

#Constants
M = 29.0e-3
R = 8.31
P0 = 1.0e5
g0 = 9.8
RT = 6.4e3
pi = np.pi

#Altitude en km
zexp = np.array([0.0, 5.0, 10.0, 12.0, 20.0, 25.0, 30.0,35.0, 40.0,
                 45.0, 48.0, 52.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0, 84.0, 92.0, 95.0,100.0])

Texp = np.array([15.0, -18.0, -49.0, -56.0, -56.0, -51.0, -46.0, -37.0,
                 -22.0, -8.0, -2.0, -2.0, -7.0, -17.0, -33.0, -54.0, -65.0, -79.0, -86.0,-86.0, -81.0, -72.0])

#+BEGIN_SRC jupyter-python
fig, ax = plt.subplots()
ax.plot( Texp,zexp)
plt.savefig("graph_Q0.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/a60bc0e706dedf58e67f07c07108a1cd231a7778.png]]



 Les lignes de code seront susceptibles d'√™tre remani√©es et/ou comment√©es en fonction de vos retours.

Les tags #TABLEAU et #CODE rappellent dans lorsque les questions ont √©t√© trait√©s "au tableau" en r√©solvant les √©quations √† la main ou via des scripts (Python ou Matlab) sur les machines 


** Q1 - formule de l'interpolation -                                :Tableau:
:PROPERTIES:  
:UNNUMBERED: t  
:END:  

 Ce point a √©t√© trait√© en s√©ance au tableau (TAG: Tableau)

Consid√©rons un petit intervalle $Z_{i}$ = $\left[ z_{i} ; z_{i+1} \right]$ et pla√ßons en ordonn√©e deux points successifs $M_{i} \left( z_i,T_i \right)$ et $M_{i+1} \left ( z_{i+1}, T_{i+1} \right)$. Nous avons r√©pondu √† l'oral aux questions suivantes :

+ Que vaut la temp√©rature correspondant √† un point milieu de cet intervalle ?
+ De combien de param√®tres d√©pend la fonction d'interpolation affine $T(z)$ sur $Z_{i}$ ?
+ Exprimer les en fonction des donn√©es mesur√©es aux points $M_{i}(z_i,T_i)$ et $M_{i+1}(z_{i+1}, T_{i+1})$.


Dans ce cas simple, on peut bien s√ªr trouver la solution par tat√¥nnements. On pourra sinon poser proprement un syst√®me d'√©quations, avec autant d'√©quations que d'inconnues, m√©thode qui s'av√©rera toujours payante pour les techniques d'interpolation plus sophistiqu√©es ...

** Q2 -                                                                :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def T(z, unite):
    z_km = z / 1000 # Conversion en km pour comparaison dans la liste
    alpha = 1 # Valeur par d√©faut pour la conversion en K
    if unite == 'C':
        alpha = 0 # Pas de d√©calage pour la temp√©rature en ¬∞C
    i = 0
    while z_km > zexp[i + 1]: # Recherche de l‚Äôindice i
        i = i + 1
    temperature = alpha*273 + Texp[i] + (z_km - zexp[i])/(zexp[i + 1] - zexp[i])*(Texp[i + 1] - Texp[i]) # Interpolation lin√©aire
    return temperature
 #+END_SRC

 #+RESULTS:

** Q3                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
N = 1000 # Nombre de points
zmax = 100.0e3 # Altitude max (en m)
dz = zmax/(N - 1) # Pas spatial (en m)
zatm = np.array([k*dz for k in range(N)]) # Altitudes
Tatm = np.array([T(zatm[k], 'C') for k in range(N)]) # Temp√©ratures
 #+END_SRC

 #+RESULTS:


** Q4                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Tatm,zatm)
ax.plot( Tatm,zatm)
plt.savefig("graph_Q4.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/bce4b3c06ad759508b4d43d220f481ab699a1e96.png]]


** Q5                                                          :TABLEAU:EXAM:

On montre que : 

$$\rho(z)= \frac{M P(z)}{R T(z)} $$ 

Question classique, n√©c√©ssitant de manipuler **l'√©quation des gaz parfaits** coupl√©e aux d√©finitions des **masses molaires** et **masses volumiques**. 

**remarque** : quelques √©tudiants ont eu des difficult√©s √† retrouver la formule rapidement. (Pour y rem√©dier, des techniques ont √©t√© pr√©sent√©es ...). Penser qu'on sait par avance "la forme alg√©brique" du r√©sultat (rapport de produits de parm√®tres). Cela invite √† Jouer avec les unit√©s. Il suffit d'un peu de pratique et sens physique (La masse volumique augmente-t-elle lorsque la temp√©rature augmente ? augmente-elle lorsque la pression augmente ou dimimune ?)



A savoir traiter √† l'examen ! 




** Q6                                                               :TABLEAU:

Un autre classique (le fameux grad de P √©gal ROGER, mn√©motechnique) : 

$$ \vec{\nabla} P = \rho \vec{g}$$

On peut s'entrainer √† retrouver ce r√©sultat en faisant un petit bilan des forces (de pression + gravit√©) exerc√©es sur une tranche d'air d'√©paisseur $dz$ et de section $S$ : 

On a en dessous, $p(z)S$ et en dessus $p(z+dz)S$. Le poids $\rho(z) g S dz$ s'applique au centre de gravit√©. D'o√π 

$$ p(z+dz) -p(z) = - \rho g  dz $$

qui se r√©√©crit $$ dp/dz = -\rho g $$ soit en explicitant $\rho$ : 

$$ \frac{dP}{dz} + \frac{M g(z)}{R T(z)} p(z) = 0 $$

** Q7

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def g(z): # Champ de pesanteur
    return g0 * RT**2 / (RT + z)**2
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
# Calcul du champ de pression par la m√©thode d‚ÄôEuler
Patm = [P0] # Initialisation
for k in range(N - 1): # Il reste N - 1 termes √† calculer
    Patm.append(Patm[k] - M*g(zatm[k])*Patm[k]*dz/(R*T(zatm[k], 'K')))
Patm = np.array(Patm) # Conversion en tableau
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Patm,zatm)
plt.savefig("graph_Q7.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/452be962270a3497e78002b893546d6fd18cd61c.png]]


** Q8                                                                  :CODE:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
def masse_atm(z): # Calcul de la masse d‚Äôair jusqu‚Äô√† l‚Äôaltitude z
    masse = 0
    k = 0
    while zatm[k] < z: # On arr√™te le calcul √† l‚Äôaltitude z
        dm = 4*np.pi*(RT + z)**2*M*Patm[k]/(R*T(zatm[k], 'K'))*dz
        masse = masse + dm
        k = k + 1
    return masse
 #+END_SRC

 #+RESULTS:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
mtot = masse_atm(100e3) # Masse d'air dans l'atmosph√®re terrestre
print('Masse de l\'atmosph√®re :', mtot, 'kg')
 #+END_SRC

 #+RESULTS:
 Masse de l'atmosph√®re : 1.0772432715500982e+16 kg
 Masse de l'atmosph√®re : 1.0772432715500982e+16 kg


 #+BEGIN_SRC jupyter-python  
mtropo = masse_atm(12e3) # Masse d'air dans la troposph√®re
print('Proportion d\'air dans la troposph√®re :', mtropo/mtot)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Proportion d'air dans la troposph√®re : 0.004662119957938924
 :END:


** Q9                                                               :TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Patm2 = [P0]
for k in range(N - 1):
    Patm2.append(Patm2[k] - M*g0*Patm2[k]*dz/(R*T(zatm[k], 'K')))
Patm2 = np.array(Patm2)
ecart1 = 100 * abs(Patm - Patm2) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart1,zatm)
plt.savefig("graph_Q9.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/976970ca5f6bd41e43d20f0987b5263393e64f05.png]]



** Q10                                                                 :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Piso = [P0]
for k in range(N - 1):
    Piso.append(Piso[k] - M*g0*Piso[k]*dz/(R*T(0, 'K')))
Piso = np.array(Piso)
ecart2 = 100 * abs(Piso - Patm) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart2,zatm)
plt.savefig("graph_Q10.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/feb8952deba53f364be4f1ff78bba0a4ceaf611b.png]]


** Q11                                                              :TABLEAU:

** Q12                                                         :CODE:TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
ztropo, Ttropo = [], [] # Initialisation des listes
k = 0
while zatm[k] < 10e3: # On s√©lectionne les donn√©es jusqu‚Äô√† 10km
    ztropo.append(zatm[k])
    Ttropo.append(T(zatm[k], 'K'))
    k = k + 1 # NB:: On a pris en fait 1 point sur 5 pour le graphe
# R√©gression lin√©aire T(z)=a*z+b
a, b = np.polyfit(ztropo, Ttropo, 1) # Calcul de la r√©gression lin√©aire
Tlin = [a*z + b for z in ztropo] # Mod√®le lin√©aire de la temp√©rature


print(a,b)
 #+END_SRC

 #+RESULTS:
 -0.006402700270027003 287.5138802168507
 -0.006402700270027003 287.5138802168507


 #+BEGIN_SRC jupyter-python :results output raw :exports both
Pgradient = [P0]
for k in range(len(ztropo) - 1):
    Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
Pgradient = np.array(Pgradient)
ecart3 = 100 * abs(Pgradient - Patm) / Patm
 #+END_SRC

 #+RESULTS:
 # [goto error]
 [0;31m[0m
 [0;31mValueError[0mTraceback (most recent call last)
 [0;32m<ipython-input-16-8ae4b0545b27>[0m in [0;36m<module>[0;34m[0m
 [1;32m      3[0m     [0mPgradient[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m-[0m [0mM[0m[0;34m*[0m[0mg0[0m[0;34m*[0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m[0;34m*[0m[0mdz[0m[0;34m/[0m[0;34m([0m[0mR[0m[0;34m*[0m[0;34m([0m[0ma[0m[0;34m*[0m[0mzatm[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m+[0m [0mb[0m[0;34m)[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [1;32m      4[0m [0mPgradient[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0marray[0m[0;34m([0m[0mPgradient[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 5[0;31m [0mecart3[0m [0;34m=[0m [0;36m100[0m [0;34m*[0m [0mabs[0m[0;34m([0m[0mPgradient[0m [0;34m-[0m [0mPatm[0m[0;34m)[0m [0;34m/[0m [0mPatm[0m[0;34m[0m[0;34m[0m[0m
 [0m
 [0;31mValueError[0m: operands could not be broadcast together with shapes (100,) (1000,) 
 # [goto error]
 [0;31m[0m
 [0;31mValueError[0mTraceback (most recent call last)
 [0;32m<ipython-input-16-8ae4b0545b27>[0m in [0;36m<module>[0;34m[0m
 [1;32m      3[0m     [0mPgradient[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m-[0m [0mM[0m[0;34m*[0m[0mg0[0m[0;34m*[0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m[0;34m*[0m[0mdz[0m[0;34m/[0m[0;34m([0m[0mR[0m[0;34m*[0m[0;34m([0m[0ma[0m[0;34m*[0m[0mzatm[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m+[0m [0mb[0m[0;34m)[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [1;32m      4[0m [0mPgradient[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0marray[0m[0;34m([0m[0mPgradient[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 5[0;31m [0mecart3[0m [0;34m=[0m [0;36m100[0m [0;34m*[0m [0mabs[0m[0;34m([0m[0mPgradient[0m [0;34m-[0m [0mPatm[0m[0;34m)[0m [0;34m/[0m [0mPatm[0m[0;34m[0m[0;34m[0m[0m
 [0m
 [0;31mValueError[0m: operands could not be broadcast together with shapes (100,) (1000,) 


 #+RESULTS:
 :RESULTS:
 100
 :END:
 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart3,zatm)
plt.savefig("graph_Q12.png")
 #+END_SRC

 #+RESULTS:
 # [goto error]
 [0;31m[0m
 [0;31mNameError[0mTraceback (most recent call last)
 [0;32m<ipython-input-17-c79f05ea19df>[0m in [0;36m<module>[0;34m[0m
 [1;32m      1[0m [0mfig[0m[0;34m,[0m [0max[0m [0;34m=[0m [0mplt[0m[0;34m.[0m[0msubplots[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 2[0;31m [0max[0m[0;34m.[0m[0mplot[0m[0;34m([0m [0mecart3[0m[0;34m,[0m[0mzatm[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0m[1;32m      3[0m [0mplt[0m[0;34m.[0m[0msavefig[0m[0;34m([0m[0;34m"graph_Q12.png"[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

 [0;31mNameError[0m: name 'ecart3' is not defined
 [[file:./.ob-jupyter/61d2780d035746e2a1d41c3696837d1141c39f65.png]]

 #+BEGIN_SRC jupyter-python  

 #+END_SRC


