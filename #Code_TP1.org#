#+TITLE: Structure Thermique de l'atmopshère
#+AUTHOR: Thomas Lebrat
#+DATE: <2023-02-01 mer.>

#+OPTIONS: d:nil

:tiroir:
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
# #+SETUPFILE: file:///~/org-html-themes/org/theme-readtheorg-local.setup
:end:


* Introduction

Un ballon-sonde mesure les caractéristiques de l'atmosphère à l'aide d'instruments embarqués jusque des altitudes variables (selon les modèles, ouverts ou fermés). On retient souvent une valeur approchée de $50~km$ pour l'altitude maximale. Est-ce bien réaliste ? Pourquoi une telle limite ? 

Les données obtenues en fonction de l'altitude sont renvoyées au sol par signal radio. L'importance de ces données /in situ/ est cruciale pour affiner les modèles physiques de l'atmosphère utilisés en météorologie et notamment /calibrer/ les mesures réalisées par satellite à des fin de télédétection.


** Objectifs de l'activité et compétences travaillées

Nous vous fournissons ici une vingtaine de valeurs de température à analyser. Les questions Q1 à Q12 vous guident pour atteindre les 3 ojectifs principaux de cette activité : 

1) Construire des profils verticaux $\rightarrow$ identifier les couches atmosphériques
2) Déterminer un profil de pression $\looparrowright$ 100 km tenant compte de $\Delta T$
3) Discuter la pertinence du choix de certaines hypothèses (iso-g, iso-T)

Une participation active et constructive est toujours bienvenue et valorisée. Vous êtes autorisés (et encouragés !) à nous solliciter pour nous soumettre vos questions scientifiques (ex: /Mais c'est quoi un gradient adiabatique ?/) ou techniques (ex: /Comment faire converger mon algorithme efficacement ?/). 

Voici une liste des compétences qui sont travaillées dans ce TP : 

- Implémenter des méthodes numériques : *interpolation* et *intégration*
- Comprendre le principe de la *régression* 
- Explorer quelques possibités du language ~Python~ + ~numpy~ \footnote{avec l'utilisation de ~Matplotlib~ syntaxe proche de ~MATLAB~}

Accéssoirement, vous pourrez utiliser des librairies spécialisées telles que ~scipy~, ~pandas~, ~plotly~ (...) et d'autres outils que vous aimeriez partager s'il permettent de gagner du temps de développement ou du temps de calcul.



** Documentation et remerciements

*** biblio
:PROPERTIES:  
:UNNUMBERED: t  
:END:  
 Cette activité est très largement inspirée de la lecture des documents suivants (liste à compléter)
 
+ [[https://labolycee.org/mecanique-du-vol-dun-ballon-sonde][Exo Bac]]
+ [[http://www.msc.univ-paris-diderot.fr/~phyexp/pmwiki.php/Convention/ConvectionEtPanacheThermique][Images de panaches thermiques (UP7)]]
+ [[https://web.archive.org/web/20081119164748/http://www.meteofrance.com/FR/glossaire/designation/693_initie_view.jsp][Glossaire Meteo France]]
+ [[http://b.louchart.free.fr/Concours_et_examens/Centrale_Supelec/Sujets/2008_TSI_Physique_1.html][Sujet Concours TSI 2008]]
+ [[https://planet-terre.ens-lyon.fr/ressource/mouvts-enveloppes-fluides2.xml][Site Planète Terre ENS Lyon]]

*** TODO nommenclature et origine des noms des couches
:PROPERTIES:  
    :UNNUMBERED: t
    :END:      




** Tableau commenté


#+BEGIN_EXPORT latex
Voici le profil vertical avec une petite une visualisation ~ASCII~ artisanale\footnote{Depuis Emacs(org-mode), on applique la formule :  \#+TBLFM: ~\$4='(orgtbl-ascii-draw \$3 175 290)~}. 
#+END_EXPORT

 #+NAME: temp
 #+name: name
 #+attr_latex: : |c|c|c|c|
 #+caption:
 | z(km) | T(°C) |  T(K) | T (ASCII Profile) |
 |-------+-------+-------+-------------------|
 |   100 |   -72 |   201 | WWh               |
 |    95 |   -81 |   192 | WV                |
 |    92 |   -86 | *187* | W;                |
 |    84 |   -86 | *187* | W;                |
 |    80 |   -86 | *187* | W;                |
 |    75 |   -79 |   194 | WW                |
 |    70 |   -65 |   208 | WWWc              |
 |    65 |   -54 |   219 | WWWWl             |
 |    60 |   -33 |   240 | WWWWWWV           |
 |    55 |   -17 |   256 | WWWWWWWW!         |
 |    52 |    -7 |   266 | WWWWWWWWW!        |
 |    48 |    -2 | *271* | WWWWWWWWWW        |
 |    45 |    -2 | *271* | WWWWWWWWWW        |
 |    40 |    -8 |   265 | WWWWWWWWWc        |
 |    35 |   -22 |   251 | WWWWWWWH          |
 |    30 |   -37 |   236 | WWWWWWc           |
 |    25 |   -46 |   227 | WWWWWc            |
 |    20 |   -56 | *217* | WWWWc             |
 |    12 |   -56 | *217* | WWWWc             |
 |    10 |   -49 |   224 | WWWWW.            |
 |     5 |   -18 |   255 | WWWWWWWW;         |
 |     0 |    15 | *288* | WWWWWWWWWWWV      |
#+TBLFM: $4=$2+273
#+TBLFM: $4='(orgtbl-ascii-draw $3 175 290)

On repère les tendances discutées au premmier cours, les creux et les bosses correspondant aux /minima/ et /maxima/ locaux. Des valeurs identiques pourraient indiquer des bandes stationnaires mais l'échantillonage est insuffisant pour trancher.

Le tableau de données est saisi à la main puis commenté en groupe : 

+  << il fait froid >> : en effet la température $T$ est  toujours (vraiment ?) négative au delà de 5 km
+ à l'évidence, $T$ n'est connue qu'en certaines altitudes, espacées de manière /irrégulière/
+ depuis le sol, des tendances sont identifiables : $\searrow$ , $\nearrow$ , $\searrow$ , $\nearrow$
+ des mesures font apparaître des valeurs identiques (stagnation ?)
+ les étudiants se demandent alors si cela ne posera pas de problème numérique (ce point à été traité en détail à l'oral en TP ...)

Attention, la conversion en Kelvin peut-être source d'erreurs ! Pour nos calculs, on prendra garde à bien vérifier que le zero absolu correspond à une température de $-273~C$ c-à-d que : 

$$T(K) = T(C) + 273 $$


* TP Sondage Atmosphérique - Correction 

** préparatifs

 - On importe les librairies standards et on fixe les valeurs des constantes physiques.
 - On saisie les tableaux de valeurs de température
 - On teste l'execution dans une première cellule (Jupyter Notebook par ex)


 #+BEGIN_SRC jupyter-python :results output raw :exports both
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

#Constants
M = 29.0e-3
R = 8.31
P0 = 1.0e5
g0 = 9.8
RT = 6.4e3
pi = np.pi

#Altitude en km
zexp = np.array([0.0, 5.0, 10.0, 12.0, 20.0, 25.0, 30.0,35.0, 40.0,
                 45.0, 48.0, 52.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0, 84.0, 92.0, 95.0,100.0])

Texp = np.array([15.0, -18.0, -49.0, -56.0, -56.0, -51.0, -46.0, -37.0,
                 -22.0, -8.0, -2.0, -2.0, -7.0, -17.0, -33.0, -54.0, -65.0, -79.0, -86.0,-86.0, -81.0, -72.0])

#+BEGIN_SRC jupyter-python
fig, ax = plt.subplots()
ax.plot( Texp,zexp)
plt.savefig("graph_Q0.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/a60bc0e706dedf58e67f07c07108a1cd231a7778.png]]



 Les lignes de code seront susceptibles d'être remaniées et/ou commentées en fonction de vos retours.

Les tags #TABLEAU et #CODE rappellent dans lorsque les questions ont été traités "au tableau" en résolvant les équations à la main ou via des scripts (Python ou Matlab) sur les machines 


** Q1 - formule de l'interpolation -                                :Tableau:
:PROPERTIES:  
:UNNUMBERED: t  
:END:  

 Ce point a été traité en séance au tableau (TAG: Tableau)

Considérons un petit intervalle $Z_{i}$ = $\left[ z_{i} ; z_{i+1} \right]$ et plaçons en ordonnée deux points successifs $M_{i} \left( z_i,T_i \right)$ et $M_{i+1} \left ( z_{i+1}, T_{i+1} \right)$. Nous avons répondu à l'oral aux questions suivantes :

+ Que vaut la température correspondant à un point milieu de cet intervalle ?
+ De combien de paramètres dépend la fonction d'interpolation affine $T(z)$ sur $Z_{i}$ ?
+ Exprimer les en fonction des données mesurées aux points $M_{i}(z_i,T_i)$ et $M_{i+1}(z_{i+1}, T_{i+1})$.


Dans ce cas simple, on peut bien sûr trouver la solution par tatônnements. On pourra sinon poser proprement un système d'équations, avec autant d'équations que d'inconnues, méthode qui s'avérera toujours payante pour les techniques d'interpolation plus sophistiquées ...

** Q2 -                                                                :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def T(z, unite):
    z_km = z / 1000 # Conversion en km pour comparaison dans la liste
    alpha = 1 # Valeur par défaut pour la conversion en K
    if unite == 'C':
        alpha = 0 # Pas de décalage pour la température en °C
    i = 0
    while z_km > zexp[i + 1]: # Recherche de l’indice i
        i = i + 1
    temperature = alpha*273 + Texp[i] + (z_km - zexp[i])/(zexp[i + 1] - zexp[i])*(Texp[i + 1] - Texp[i]) # Interpolation linéaire
    return temperature
 #+END_SRC

 #+RESULTS:

** Q3                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
N = 1000 # Nombre de points
zmax = 100.0e3 # Altitude max (en m)
dz = zmax/(N - 1) # Pas spatial (en m)
zatm = np.array([k*dz for k in range(N)]) # Altitudes
Tatm = np.array([T(zatm[k], 'C') for k in range(N)]) # Températures
 #+END_SRC

 #+RESULTS:


** Q4                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Tatm,zatm)
ax.plot( Tatm,zatm)
plt.savefig("graph_Q4.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/bce4b3c06ad759508b4d43d220f481ab699a1e96.png]]


** Q5                                                          :TABLEAU:EXAM:

On montre que : 

$$\rho(z)= \frac{M P(z)}{R T(z)} $$ 

Question classique, nécéssitant de manipuler **l'équation des gaz parfaits** couplée aux définitions des **masses molaires** et **masses volumiques**. 

**remarque** : quelques étudiants ont eu des difficultés à retrouver la formule rapidement. (Pour y remédier, des techniques ont été présentées ...). Penser qu'on sait par avance "la forme algébrique" du résultat (rapport de produits de parmètres). Cela invite à Jouer avec les unités. Il suffit d'un peu de pratique et sens physique (La masse volumique augmente-t-elle lorsque la température augmente ? augmente-elle lorsque la pression augmente ou dimimune ?)



A savoir traiter à l'examen ! 




** Q6                                                               :TABLEAU:

Un autre classique (le fameux grad de P égal ROGER, mnémotechnique) : 

$$ \vec{\nabla} P = \rho \vec{g}$$

On peut s'entrainer à retrouver ce résultat en faisant un petit bilan des forces (de pression + gravité) exercées sur une tranche d'air d'épaisseur $dz$ et de section $S$ : 

On a en dessous, $p(z)S$ et en dessus $p(z+dz)S$. Le poids $\rho(z) g S dz$ s'applique au centre de gravité. D'où 

$$ p(z+dz) -p(z) = - \rho g  dz $$

qui se réécrit $$ dp/dz = -\rho g $$ soit en explicitant $\rho$ : 

$$ \frac{dP}{dz} + \frac{M g(z)}{R T(z)} p(z) = 0 $$

** Q7

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def g(z): # Champ de pesanteur
    return g0 * RT**2 / (RT + z)**2
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
# Calcul du champ de pression par la méthode d’Euler
Patm = [P0] # Initialisation
for k in range(N - 1): # Il reste N - 1 termes à calculer
    Patm.append(Patm[k] - M*g(zatm[k])*Patm[k]*dz/(R*T(zatm[k], 'K')))
Patm = np.array(Patm) # Conversion en tableau
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Patm,zatm)
plt.savefig("graph_Q7.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/452be962270a3497e78002b893546d6fd18cd61c.png]]


** Q8                                                                  :CODE:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
def masse_atm(z): # Calcul de la masse d’air jusqu’à l’altitude z
    masse = 0
    k = 0
    while zatm[k] < z: # On arrête le calcul à l’altitude z
        dm = 4*np.pi*(RT + z)**2*M*Patm[k]/(R*T(zatm[k], 'K'))*dz
        masse = masse + dm
        k = k + 1
    return masse
 #+END_SRC

 #+RESULTS:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
mtot = masse_atm(100e3) # Masse d'air dans l'atmosphère terrestre
print('Masse de l\'atmosphère :', mtot, 'kg')
 #+END_SRC

 #+RESULTS:
 Masse de l'atmosphère : 1.0772432715500982e+16 kg
 Masse de l'atmosphère : 1.0772432715500982e+16 kg


 #+BEGIN_SRC jupyter-python  
mtropo = masse_atm(12e3) # Masse d'air dans la troposphère
print('Proportion d\'air dans la troposphère :', mtropo/mtot)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Proportion d'air dans la troposphère : 0.004662119957938924
 :END:


** Q9                                                               :TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Patm2 = [P0]
for k in range(N - 1):
    Patm2.append(Patm2[k] - M*g0*Patm2[k]*dz/(R*T(zatm[k], 'K')))
Patm2 = np.array(Patm2)
ecart1 = 100 * abs(Patm - Patm2) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart1,zatm)
plt.savefig("graph_Q9.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/976970ca5f6bd41e43d20f0987b5263393e64f05.png]]



** Q10                                                                 :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Piso = [P0]
for k in range(N - 1):
    Piso.append(Piso[k] - M*g0*Piso[k]*dz/(R*T(0, 'K')))
Piso = np.array(Piso)
ecart2 = 100 * abs(Piso - Patm) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart2,zatm)
plt.savefig("graph_Q10.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/feb8952deba53f364be4f1ff78bba0a4ceaf611b.png]]


** Q11                                                              :TABLEAU:

** Q12                                                         :CODE:TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
ztropo, Ttropo = [], [] # Initialisation des listes
k = 0
while zatm[k] < 10e3: # On sélectionne les données jusqu’à 10km
    ztropo.append(zatm[k])
    Ttropo.append(T(zatm[k], 'K'))
    k = k + 1 # NB:: On a pris en fait 1 point sur 5 pour le graphe
# Régression linéaire T(z)=a*z+b
a, b = np.polyfit(ztropo, Ttropo, 1) # Calcul de la régression linéaire
Tlin = [a*z + b for z in ztropo] # Modèle linéaire de la température


print(a,b)
 #+END_SRC

 #+RESULTS:
 -0.006402700270027003 287.5138802168507
 -0.006402700270027003 287.5138802168507


 #+BEGIN_SRC jupyter-python :results output raw :exports both
Pgradient = [P0]
for k in range(len(ztropo) - 1):
    Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
Pgradient = np.array(Pgradient)
ecart3 = 100 * abs(Pgradient - Patm) / Patm
 #+END_SRC

 #+RESULTS:
 # [goto error]
 [0;31m[0m
 [0;31mValueError[0mTraceback (most recent call last)
 [0;32m<ipython-input-16-8ae4b0545b27>[0m in [0;36m<module>[0;34m[0m
 [1;32m      3[0m     [0mPgradient[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m-[0m [0mM[0m[0;34m*[0m[0mg0[0m[0;34m*[0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m[0;34m*[0m[0mdz[0m[0;34m/[0m[0;34m([0m[0mR[0m[0;34m*[0m[0;34m([0m[0ma[0m[0;34m*[0m[0mzatm[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m+[0m [0mb[0m[0;34m)[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [1;32m      4[0m [0mPgradient[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0marray[0m[0;34m([0m[0mPgradient[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 5[0;31m [0mecart3[0m [0;34m=[0m [0;36m100[0m [0;34m*[0m [0mabs[0m[0;34m([0m[0mPgradient[0m [0;34m-[0m [0mPatm[0m[0;34m)[0m [0;34m/[0m [0mPatm[0m[0;34m[0m[0;34m[0m[0m
 [0m
 [0;31mValueError[0m: operands could not be broadcast together with shapes (100,) (1000,) 
 # [goto error]
 [0;31m[0m
 [0;31mValueError[0mTraceback (most recent call last)
 [0;32m<ipython-input-16-8ae4b0545b27>[0m in [0;36m<module>[0;34m[0m
 [1;32m      3[0m     [0mPgradient[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m-[0m [0mM[0m[0;34m*[0m[0mg0[0m[0;34m*[0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m[0;34m*[0m[0mdz[0m[0;34m/[0m[0;34m([0m[0mR[0m[0;34m*[0m[0;34m([0m[0ma[0m[0;34m*[0m[0mzatm[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m+[0m [0mb[0m[0;34m)[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [1;32m      4[0m [0mPgradient[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0marray[0m[0;34m([0m[0mPgradient[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 5[0;31m [0mecart3[0m [0;34m=[0m [0;36m100[0m [0;34m*[0m [0mabs[0m[0;34m([0m[0mPgradient[0m [0;34m-[0m [0mPatm[0m[0;34m)[0m [0;34m/[0m [0mPatm[0m[0;34m[0m[0;34m[0m[0m
 [0m
 [0;31mValueError[0m: operands could not be broadcast together with shapes (100,) (1000,) 


 #+RESULTS:
 :RESULTS:
 100
 :END:
 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart3,zatm)
plt.savefig("graph_Q12.png")
 #+END_SRC

 #+RESULTS:
 # [goto error]
 [0;31m[0m
 [0;31mNameError[0mTraceback (most recent call last)
 [0;32m<ipython-input-17-c79f05ea19df>[0m in [0;36m<module>[0;34m[0m
 [1;32m      1[0m [0mfig[0m[0;34m,[0m [0max[0m [0;34m=[0m [0mplt[0m[0;34m.[0m[0msubplots[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 2[0;31m [0max[0m[0;34m.[0m[0mplot[0m[0;34m([0m [0mecart3[0m[0;34m,[0m[0mzatm[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0m[1;32m      3[0m [0mplt[0m[0;34m.[0m[0msavefig[0m[0;34m([0m[0;34m"graph_Q12.png"[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

 [0;31mNameError[0m: name 'ecart3' is not defined
 [[file:./.ob-jupyter/61d2780d035746e2a1d41c3696837d1141c39f65.png]]

 #+BEGIN_SRC jupyter-python  

 #+END_SRC


