#+TITLE: Structure Thermique de l'atmopshÃ¨re
#+AUTHOR: Thomas Lebrat
#+DATE: <2023-02-01 mer.>

#+OPTIONS: d:nil

:tiroir:
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
# #+SETUPFILE: file:///~/org-html-themes/org/theme-readtheorg-local.setup
:end:


* Introduction

** Objectifs de l'activitÃ© et compÃ©tences travaillÃ©es

Un ballon-sonde mesure les caractÃ©ristiques de l'atmosphÃ¨re Ã  l'aide d'instruments embarquÃ©s jusque des altitudes variables selon les modÃ¨les (ouverts/fermÃ©s) et les circonstances. On retient souvent la valeur approchÃ©e de $50~km$. Est-ce bien rÃ©aliste et pourquoi une telle limite ?

Les donnÃ©es obtenues en fonction de l'altitude sont renvoyÃ©es au sol par signal radio. L'importance de ces donnÃ©es /in situ/ est cruciale pour affiner les modÃ¨les physiques de l'atmosphÃ¨re utilisÃ©s en mÃ©tÃ©orologie et notamment /calibrer/ les mesures rÃ©alisÃ©es par satellite Ã  des fin de tÃ©lÃ©dÃ©tection.

Nous vous fournissons ici une vingtaine de valeurs de tempÃ©rature Ã  analyser. Les questions Q1 Ã  Q12 vous guident pour atteindre les 3 ojectifs principaux de cette activitÃ© : 

1) Construire des profils verticaux $\rightarrow$ identifier les couches atmosphÃ©riques
2) DÃ©terminer un profil de pression $\looparrowright$ 100 km tenant compte de $\Delta T$
3) Discuter la pertinence du choix de certaines hypothÃ¨ses (iso-g, iso-T)

Une participation active et constructive est toujours bienvenue et valorisÃ©e. Vous Ãªtes autorisÃ©s (et encouragÃ©s !) Ã  nous solliciter pour nous soumettre vos questions scientifiques (ex: /Mais c'est quoi un gradient adiabatique ?/) ou techniques (ex: /Comment faire converger mon algorithme efficacement ?/). 

Voici une liste des compÃ©tences qui sont travaillÃ©es dans ce module : 

- ImplÃ©menter des mÃ©thodes numÃ©riques : *interpolation* et *intÃ©gration*
- Comprendre le principe de la *rÃ©gression* 
- Explorer quelques possibitÃ©s du language ~Python~ + ~numpy~ \footnote{avec l'utilisation de ~Matplotlib~ syntaxe proche de ~MATLAB~\texttrademark}

AccÃ©ssoirement, vous pourrez utiliser des librairies spÃ©cialisÃ©es telles que ~scipy~, ~pandas~, ~plotly~ (...) et d'autres outils que vous aimeriez partager s'il permettent de gagner du temps de dÃ©veloppement ou du temps de calcul.



** Documentation et remerciements

*** biblio
:PROPERTIES:  
:UNNUMBERED: t  
:END:  
 Cette activitÃ© est trÃ¨s largement inspirÃ©e de la lecture des documents suivants (liste Ã  complÃ©ter)
 
+ [[https://labolycee.org/mecanique-du-vol-dun-ballon-sonde][Exo Bac]]
+ [[http://www.msc.univ-paris-diderot.fr/~phyexp/pmwiki.php/Convention/ConvectionEtPanacheThermique][Images de panaches thermiques (UP7)]]
+ [[https://web.archive.org/web/20081119164748/http://www.meteofrance.com/FR/glossaire/designation/693_initie_view.jsp][Glossaire Meteo France]]
+ [[http://b.louchart.free.fr/Concours_et_examens/Centrale_Supelec/Sujets/2008_TSI_Physique_1.html][Sujet Concours TSI 2008]]
+ [[https://planet-terre.ens-lyon.fr/ressource/mouvts-enveloppes-fluides2.xml][Site PlanÃ¨te Terre ENS Lyon]]

*** TODO nommenclature et origine des noms des couches
:PROPERTIES:  
    :UNNUMBERED: t
    :END:      


 \newpage




* TP Sondage AtmosphÃ©rique

** prÃ©paratifs

 - On importe les librairies standards et on fixe les valeurs des constantes physiques.
 - On saisie les tableaux de valeurs de tempÃ©rature
 - On teste l'execution dans une premiÃ¨re cellule (Jupyter Notebook par ex)


 #+BEGIN_SRC jupyter-python :results output raw :exports both
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

#Constants
M = 29.0e-3
R = 8.31
P0 = 1.0e5
g0 = 9.8
RT = 6.4e3
pi = np.pi

#Altitude en km
zexp = np.array([0.0, 5.0, 10.0, 12.0, 20.0, 25.0, 30.0,35.0, 40.0,
                 45.0, 48.0, 52.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0, 84.0, 92.0, 95.0,100.0])

Texp = np.array([15.0, -18.0, -49.0, -56.0, -56.0, -51.0, -46.0, -37.0,
                 -22.0, -8.0, -2.0, -2.0, -7.0, -17.0, -33.0, -54.0, -65.0, -79.0, -86.0,-86.0, -81.0, -72.0])

#+BEGIN_SRC jupyter-python
fig, ax = plt.subplots()
ax.plot( Texp,zexp)
plt.savefig("graph_Q0.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/a60bc0e706dedf58e67f07c07108a1cd231a7778.png]]




 Voici quelques premiers Ã©lÃ©ments de correction. 

 Les lignes de code seront susceptibles d'Ãªtre remaniÃ©es et/ou commentÃ©es en fonction de vos retours.


** Q1 - formule de l'interpolation -                                :Tableau:

 Ce point a Ã©tÃ© traitÃ© en sÃ©ance au tableau (TAG: Tableau)

** Q2 -                                                                :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def T(z, unite):
    z_km = z / 1000 # Conversion en km pour comparaison dans la liste
    alpha = 1 # Valeur par dÃ©faut pour la conversion en K
    if unite == 'C':
        alpha = 0 # Pas de dÃ©calage pour la tempÃ©rature en Â°C
    i = 0
    while z_km > zexp[i + 1]: # Recherche de lâ€™indice i
        i = i + 1
    temperature = alpha*273 + Texp[i] + (z_km - zexp[i])/(zexp[i + 1] - zexp[i])*(Texp[i + 1] - Texp[i]) # Interpolation linÃ©aire
    return temperature
 #+END_SRC

 #+RESULTS:

** Q3                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
N = 1000 # Nombre de points
zmax = 100.0e3 # Altitude max (en m)
dz = zmax/(N - 1) # Pas spatial (en m)
zatm = np.array([k*dz for k in range(N)]) # Altitudes
Tatm = np.array([T(zatm[k], 'C') for k in range(N)]) # TempÃ©ratures
 #+END_SRC

 #+RESULTS:


** Q4                                                                  :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Tatm,zatm)
ax.plot( Tatm,zatm)
plt.savefig("graph_Q4.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/bce4b3c06ad759508b4d43d220f481ab699a1e96.png]]


** Q5                                                               :TABLEAU:

** Q6                                                               :TABLEAU:

** Q7

 #+BEGIN_SRC jupyter-python :results output raw :exports both
def g(z): # Champ de pesanteur
    return g0 * RT**2 / (RT + z)**2
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
# Calcul du champ de pression par la mÃ©thode dâ€™Euler
Patm = [P0] # Initialisation
for k in range(N - 1): # Il reste N - 1 termes Ã  calculer
    Patm.append(Patm[k] - M*g(zatm[k])*Patm[k]*dz/(R*T(zatm[k], 'K')))
Patm = np.array(Patm) # Conversion en tableau
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( Patm,zatm)
plt.savefig("graph_Q7.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/452be962270a3497e78002b893546d6fd18cd61c.png]]


** Q8                                                                  :CODE:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
def masse_atm(z): # Calcul de la masse dâ€™air jusquâ€™Ã  lâ€™altitude z
    masse = 0
    k = 0
    while zatm[k] < z: # On arrÃªte le calcul Ã  lâ€™altitude z
        dm = 4*np.pi*(RT + z)**2*M*Patm[k]/(R*T(zatm[k], 'K'))*dz
        masse = masse + dm
        k = k + 1
    return masse
 #+END_SRC

 #+RESULTS:


 #+BEGIN_SRC jupyter-python :results output raw :exports both
mtot = masse_atm(100e3) # Masse d'air dans l'atmosphÃ¨re terrestre
print('Masse de l\'atmosphÃ¨re :', mtot, 'kg')
 #+END_SRC

 #+RESULTS:
 Masse de l'atmosphÃ¨re : 1.0772432715500982e+16 kg


 #+BEGIN_SRC jupyter-python  
mtropo = masse_atm(12e3) # Masse d'air dans la troposphÃ¨re
print('Proportion d\'air dans la troposphÃ¨re :', mtropo/mtot)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Proportion d'air dans la troposphÃ¨re : 0.004662119957938924
 :END:


** Q9                                                               :TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Patm2 = [P0]
for k in range(N - 1):
    Patm2.append(Patm2[k] - M*g0*Patm2[k]*dz/(R*T(zatm[k], 'K')))
Patm2 = np.array(Patm2)
ecart1 = 100 * abs(Patm - Patm2) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart1,zatm)
plt.savefig("graph_Q9.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/976970ca5f6bd41e43d20f0987b5263393e64f05.png]]



** Q10                                                                 :CODE:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
Piso = [P0]
for k in range(N - 1):
    Piso.append(Piso[k] - M*g0*Piso[k]*dz/(R*T(0, 'K')))
Piso = np.array(Piso)
ecart2 = 100 * abs(Piso - Patm) / Patm # Ecart relatif
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart2,zatm)
plt.savefig("graph_Q10.png")
 #+END_SRC

 #+RESULTS:
 [[file:./.ob-jupyter/feb8952deba53f364be4f1ff78bba0a4ceaf611b.png]]


** Q11                                                              :TABLEAU:

** Q12                                                         :CODE:TABLEAU:

 #+BEGIN_SRC jupyter-python :results output raw :exports both
ztropo, Ttropo = [], [] # Initialisation des listes
k = 0
while zatm[k] < 10e3: # On sÃ©lectionne les donnÃ©es jusquâ€™Ã  10km
    ztropo.append(zatm[k])
    Ttropo.append(T(zatm[k], 'K'))
    k = k + 1 # NB:: On a pris en fait 1 point sur 5 pour le graphe
# RÃ©gression linÃ©aire T(z)=a*z+b
a, b = np.polyfit(ztropo, Ttropo, 1) # Calcul de la rÃ©gression linÃ©aire
Tlin = [a*z + b for z in ztropo] # ModÃ¨le linÃ©aire de la tempÃ©rature


print(a,b)
 #+END_SRC

 #+RESULTS:
 -0.006402700270027003 287.5138802168507


 #+BEGIN_SRC jupyter-python :results output raw :exports both
Pgradient = [P0]
for k in range(len(ztropo) - 1):
    Pgradient.append(Pgradient[k] - M*g0*Pgradient[k]*dz/(R*(a*zatm[k] + b)))
Pgradient = np.array(Pgradient)
ecart3 = 100 * abs(Pgradient - Patm) / Patm
 #+END_SRC

 #+RESULTS:
 # [goto error]
 [0;31m[0m
 [0;31mValueError[0mTraceback (most recent call last)
 [0;32m<ipython-input-16-8ae4b0545b27>[0m in [0;36m<module>[0;34m[0m
 [1;32m      3[0m     [0mPgradient[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m-[0m [0mM[0m[0;34m*[0m[0mg0[0m[0;34m*[0m[0mPgradient[0m[0;34m[[0m[0mk[0m[0;34m][0m[0;34m*[0m[0mdz[0m[0;34m/[0m[0;34m([0m[0mR[0m[0;34m*[0m[0;34m([0m[0ma[0m[0;34m*[0m[0mzatm[0m[0;34m[[0m[0mk[0m[0;34m][0m [0;34m+[0m [0mb[0m[0;34m)[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [1;32m      4[0m [0mPgradient[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0marray[0m[0;34m([0m[0mPgradient[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
 [0;32m----> 5[0;31m [0mecart3[0m [0;34m=[0m [0;36m100[0m [0;34m*[0m [0mabs[0m[0;34m([0m[0mPgradient[0m [0;34m-[0m [0mPatm[0m[0;34m)[0m [0;34m/[0m [0mPatm[0m[0;34m[0m[0;34m[0m[0m
 [0m
 [0;31mValueError[0m: operands could not be broadcast together with shapes (100,) (1000,) 


 #+RESULTS:
 :RESULTS:
 100
 :END:
 #+BEGIN_SRC jupyter-python :results output raw :exports both
fig, ax = plt.subplots()
ax.plot( ecart3,zatm)
plt.savefig("graph_Q12.png")
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # [goto error]

 NameErrorTraceback (most recent call last)
 <ipython-input-17-9c1724225630> in <module>
       1 fig, ax = plt.subplots()
 ----> 2 ax.plot( ecart3,zatm)
       3 plt.savefig("monprofil.png")

 NameError: name 'ecart3' is not defined
 [[file:./.ob-jupyter/61d2780d035746e2a1d41c3696837d1141c39f65.png]]
 :END:

 #+BEGIN_SRC jupyter-python  

 #+END_SRC

